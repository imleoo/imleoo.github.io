---
layout: post
title: "CRISPE Prompt框架实战指南：代码审查、Bug修复与APP开发完整示例"
date: 2025-12-13 10:00:00 +0800
categories: [AI, Prompt工程, 开发实践]
tags: [CRISPE, Prompt框架, 代码审查, Bug修复, Flutter, AI编程]
author_profile: true
header:
  image: /assets/images/avatar.png
  caption: "CRISPE Prompt框架实战"
toc: true
toc_sticky: true
excerpt: "深入解析CRISPE Prompt框架的实战应用，通过代码审查、Bug修复和Flutter天气APP开发三个完整示例，展示如何用结构化提示词获得高质量AI输出。"
---

> CRISPE是一个强大的Prompt结构化框架，包含六个核心要素：**C**apacity（角色）、**R**equest（任务）、**I**nput（输入）、**S**teps（步骤）、**P**arameters（参数）、**E**xamples（示例）。本文通过三个实战案例，展示如何运用CRISPE框架获得高质量的AI输出。

## CRISPE框架概述

CRISPE框架通过六个维度构建完整的提示词，让AI能够准确理解需求并生成高质量输出：

| 要素 | 含义 | 作用 |
|------|------|------|
| **C** - Capacity | 角色设定 | 定义AI扮演的专业角色 |
| **R** - Request | 具体任务 | 明确要完成的核心任务 |
| **I** - Input | 输入信息 | 提供必要的上下文和数据 |
| **S** - Steps | 执行步骤 | 规定任务的执行流程 |
| **P** - Parameters | 参数约束 | 设定输出格式和质量标准 |
| **E** - Examples | 示例参考 | 提供期望输出的样例 |

---

## 示例一：代码审查场景

### 场景背景

需要对一个登录API进行安全审查，识别潜在漏洞并提供修复建议。

### CRISPE提示词

#### 【C】角色

```
你是一位资深代码审查专家，专注于识别OWASP Top 10安全漏洞、性能问题和代码规范违规。
你的输出必须完整、专业，每个问题都附带可直接使用的修复代码。
```

#### 【R】任务

```
审查以下登录API代码，识别所有安全漏洞、性能问题和规范违规，并提供完整的修复代码。
必须输出所有发现的问题，禁止省略任何安全风险。
```

#### 【I】输入

**待审查代码：**

```javascript
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });
  if (user && user.password === password) {
    res.json({ token: generateToken(user) });
  } else {
    res.json({ error: '登录失败' });
  }
});
```

**技术栈：** Node.js + Express + MongoDB

#### 【S】步骤

1. 检查SQL注入/NoSQL注入风险
2. 检查密码存储安全性
3. 检查错误处理是否完善
4. 检查是否缺少输入验证
5. 检查性能问题(N+1查询、索引等)
6. 检查HTTP响应状态码使用是否正确
7. 对每个问题提供具体的修复代码示例
8. 输出完整的修复后代码

#### 【P】参数

**输出约束：**

- 按严重程度分级：🔴严重 🟡中等 🟢轻微
- 每个问题包含：问题描述 + 风险说明 + 修复代码
- 修复代码需完整可直接使用，禁止使用 `// ...省略` 或 `TODO`
- 输出格式为Markdown表格
- 最后必须输出完整的修复后代码

**禁止行为：**

- 禁止输出 "其他类似问题" 等省略说明
- 禁止遗漏任何安全风险
- 禁止输出不完整的代码片段

#### 【E】示例

期望输出格式：

| 问题 | 严重度 | 风险说明 | 修复代码 |
|------|--------|----------|----------|
| 密码明文存储 | 🔴 | 数据库泄露导致密码暴露 | `const isValid = await bcrypt.compare(password, user.passwordHash);` |
| 缺少错误处理 | 🟡 | 异常导致服务崩溃 | `try { ... } catch (error) { res.status(500).json({...}); }` |

**完整修复代码：**

```javascript
// 必须输出完整的、可直接运行的修复后代码
router.post('/login', async (req, res) => {
  // 完整实现...
});
```

**完整性检查表：**

```
✅ 所有安全问题已识别
✅ 所有问题已提供修复代码
✅ 完整修复代码已输出
✅ 代码可直接运行
```

### 应用要点

- **C-角色**：定义为代码审查专家，关注安全和性能
- **R-任务**：审查代码，识别问题并提供修复建议
- **I-输入**：提供待审查的代码和技术栈
- **S-步骤**：按照检查点逐一审查，最后输出完整代码
- **P-参数**：要求按严重度分级，禁止省略，输出完整代码
- **E-示例**：展示期望的表格格式和完整性检查表

CRISPE框架让代码审查**系统化、标准化**，确保不遗漏关键检查点。

---

## 示例二：Bug修复场景

### 场景背景

诊断API性能问题，响应时间从50ms突然增加到5000ms。

### CRISPE提示词

#### 【C】角色

```
你是一位Debug专家，擅长问题诊断、根因分析和性能调优。
你的输出必须包含完整的分析过程和可直接运行的修复代码。
```

#### 【R】任务

```
诊断并修复以下性能问题：API响应时间从50ms突然增加到5000ms。
必须输出完整的问题分析、性能计算和修复代码。
```

#### 【I】输入

**问题代码：**

```javascript
router.get('/users/:id/posts', async (req, res) => {
  const user = await User.findById(req.params.id);
  const posts = await Post.find({ userId: user.id });

  for (let post of posts) {
    post.author = await User.findById(post.userId);
    post.comments = await Comment.find({ postId: post.id });
  }

  res.json(posts);
});
```

**环境信息：**

- 数据库：MongoDB (远程服务器，延迟30ms)
- 用户posts数量：平均100条
- 每个post的comments：平均10条

#### 【S】步骤

1. 分析当前代码的执行流程
2. 计算数据库查询次数和总耗时（列出计算公式）
3. 识别N+1查询问题
4. 提供优化方案(使用聚合/populate/join)
5. 计算优化后的查询次数和性能提升
6. 给出完整的修复代码（可直接运行）
7. 输出性能对比表格

#### 【P】参数

**输出要求：**

- 输出包含：问题分析 + 性能计算 + 优化方案 + 修复代码
- 使用Markdown格式，代码块使用语法高亮
- 必须说明性能提升倍数
- 修复代码必须完整，禁止使用 `// TODO` 或 `// ...`

**禁止行为：**

- 禁止输出不完整的代码
- 禁止省略性能计算过程
- 禁止使用占位符

**完整性检查：**

- [ ] 问题根因已识别
- [ ] 性能计算公式已列出
- [ ] 优化方案已说明
- [ ] 完整修复代码已输出
- [ ] 性能提升倍数已计算

#### 【E】示例

期望输出格式：

```markdown
## 问题分析
N+1查询问题：循环中执行201次数据库查询

## 性能计算
| 阶段 | 查询次数 | 计算公式 | 总耗时 |
|------|---------|---------|--------|
| 当前 | 201次 | 1 + 100 + 100 | 6030ms |
| 优化后 | 3次 | 1 + 1 + 1 | 90ms |

性能提升：67倍

## 修复代码
// 完整的、可直接运行的优化代码
router.get('/users/:id/posts', async (req, res) => {
  // 完整实现，使用聚合查询
  const posts = await Post.aggregate([
    // 完整的聚合管道...
  ]);
  res.json(posts);
});

## 完整性检查
✅ 问题根因已识别：N+1查询
✅ 性能计算公式已列出
✅ 优化方案已说明：使用聚合查询
✅ 完整修复代码已输出
✅ 性能提升：67倍
```

### 应用要点

- **C-角色**：Debug专家，擅长问题诊断
- **R-任务**：诊断性能问题，从50ms到5000ms
- **I-输入**：提供问题代码和环境信息(延迟、数据量)
- **S-步骤**：分析流程 → 计算耗时 → 识别问题 → 提供方案 → 修复代码
- **P-参数**：要求说明性能提升倍数，禁止省略，输出完整代码
- **E-示例**：展示完整的输出格式和检查表

这个示例展示了CRISPE在**复杂问题诊断**中的威力。

---

## 示例三：Flutter天气APP开发

### 场景背景

开发一个完整的Flutter天气预报应用，调用公开API获取天气数据。

### CRISPE提示词

---

#### ⚠️ 强制执行指令（CRITICAL）

```
🔴 禁止行为（违反即失败）:
- 禁止输出 TODO、FIXME、待实现 等占位符
- 禁止输出 "此处省略"、"其他类似代码" 等省略说明
- 禁止使用 pass、NotImplementedError、throw "Not implemented"
- 禁止输出不完整的函数、类或Widget
- 禁止中途停止，必须完成所有功能模块

🟢 必须执行（缺一不可）:
- 每个函数必须包含完整实现代码
- 每个Widget必须完整可渲染
- 必须输出完整的单文件main.dart
- 必须在最后输出功能完整性检查表
```

---

#### 【C - Capacity 角色设定】

```
你是一位拥有8年经验的Flutter高级开发工程师，精通Dart语言、Flutter框架和Material Design设计。
你擅长状态管理、网络请求、UI/UX优化和编写高质量、可维护的移动应用代码。
你的代码输出必须完整可运行，绝不使用任何占位符或省略。
```

#### 【R - Request 具体任务】

```
一次性输出一个完整的Flutter天气预报APP，通过调用 https://wttr.in/beijing API获取天气数据。
需要实现精美的卡片式UI界面，支持下拉刷新、温度单位切换、天气图标展示。
输出必须是完整的、可直接运行的单文件代码。
```

#### 【I - Input 输入信息】

**技术栈：**

- Flutter 3.16
- Dart 3.2
- http 1.1.0 (网络请求)
- provider 6.1.0 (状态管理)

**API接口：**

- 天气数据：https://wttr.in/beijing?format=j1
- 返回JSON格式的天气信息

**设计要求：**

- 卡片式布局，渐变背景
- 显示当前温度、天气状况、湿度、风速
- 未来3天天气预报
- 支持下拉刷新
- 支持温度单位切换（摄氏度/华氏度）

**功能模块（必须全部实现）：**

| 模块 | 功能点 | 必须实现 |
|------|--------|---------|
| 数据模型 | WeatherModel解析JSON | ✅ |
| 网络服务 | WeatherService封装HTTP请求 | ✅ |
| 状态管理 | WeatherProvider管理状态 | ✅ |
| 主页面 | 城市名称、当前时间 | ✅ |
| 温度显示 | 大号温度、天气图标 | ✅ |
| 详情卡片 | 湿度、风速、体感温度 | ✅ |
| 预报卡片 | 未来3天天气 | ✅ |
| 下拉刷新 | RefreshIndicator | ✅ |
| 单位切换 | 摄氏度/华氏度切换 | ✅ |
| 加载状态 | Loading指示器 | ✅ |
| 错误处理 | 错误提示UI | ✅ |

#### 【S - Steps 执行步骤】

1. **创建WeatherModel数据模型**
   - 定义所有必要字段（温度、湿度、风速、天气描述等）
   - 实现fromJson工厂构造函数
   - 实现toJson方法

2. **实现WeatherService服务类**
   - 封装HTTP GET请求
   - 添加10秒超时处理
   - 添加try-catch错误处理
   - 返回WeatherModel对象

3. **使用Provider创建WeatherProvider状态管理**
   - 管理加载状态（isLoading）
   - 管理错误状态（errorMessage）
   - 管理天气数据（weatherData）
   - 管理温度单位（isCelsius）
   - 实现fetchWeather方法
   - 实现toggleUnit方法

4. **设计主页面WeatherHomePage**
   - 顶部显示城市名称和当前时间
   - 中部大号显示当前温度和天气图标
   - 底部卡片展示湿度、风速、体感温度等详细信息
   - 未来3天天气预报卡片

5. **实现下拉刷新功能**
   - 使用RefreshIndicator包裹
   - 调用provider的fetchWeather方法

6. **添加加载状态和错误处理UI**
   - 加载中显示CircularProgressIndicator
   - 错误时显示错误信息和重试按钮

7. **实现温度单位切换**
   - 添加切换按钮
   - 根据isCelsius显示不同单位

8. **实现渐变背景和卡片阴影效果**
   - 使用LinearGradient实现渐变
   - 使用BoxShadow实现阴影

#### 【P - Parameters 参数约束】

**代码规范：**

- 遵循Dart官方代码规范
- 使用Material Design 3设计语言
- 所有网络请求使用async/await
- 关键Widget添加中文注释

**错误处理：**

- 网络请求包裹在try-catch中
- 网络异常时显示友好的错误提示
- 添加超时处理(10秒)

**UI要求：**

- 渐变背景：从深蓝 #1E3C72 到浅蓝 #2A5298
- 卡片使用圆角(16px)和阴影效果(8px)
- 温度字体：72px，粗体，白色
- 天气图标：48x48，居中

**输出格式：**

- 生成完整的单文件main.dart代码
- 包含所有必要的import语句
- 所有函数必须完整实现，禁止占位符

**禁止行为（严格执行）：**

```
❌ 禁止: // TODO: 实现...
❌ 禁止: // 此处省略...
❌ 禁止: throw UnimplementedError()
❌ 禁止: pass 或空函数体
❌ 禁止: 不完整的Widget build方法
❌ 禁止: 中途停止输出
```

#### 【E - Examples 示例参考】

**API返回数据示例：**

```json
{
  "current_condition": [{
    "temp_C": "15",
    "temp_F": "59",
    "weatherDesc": [{"value": "Sunny"}],
    "humidity": "45",
    "windspeedKmph": "12",
    "FeelsLikeC": "14",
    "FeelsLikeF": "57"
  }],
  "weather": [
    {"date": "2024-01-15", "maxtempC": "18", "mintempC": "8", "hourly": [{"weatherDesc": [{"value": "Sunny"}]}]},
    {"date": "2024-01-16", "maxtempC": "20", "mintempC": "10", "hourly": [{"weatherDesc": [{"value": "Cloudy"}]}]},
    {"date": "2024-01-17", "maxtempC": "17", "mintempC": "7", "hourly": [{"weatherDesc": [{"value": "Rain"}]}]}
  ]
}
```

**期望的代码结构：**

```dart
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:provider/provider.dart';
import 'dart:convert';

void main() => runApp(
  ChangeNotifierProvider(
    create: (_) => WeatherProvider(),
    child: WeatherApp(),
  ),
);

// ==================== 数据模型 ====================
class WeatherModel {
  final String tempC;
  final String tempF;
  // ... 完整字段定义

  factory WeatherModel.fromJson(Map<String, dynamic> json) {
    // 完整的JSON解析实现
  }
}

// ==================== 网络服务 ====================
class WeatherService {
  Future<WeatherModel> fetchWeather(String city) async {
    // 完整的HTTP请求实现
  }
}

// ==================== 状态管理 ====================
class WeatherProvider extends ChangeNotifier {
  // 完整的状态管理实现
}

// ==================== 主应用 ====================
class WeatherApp extends StatelessWidget {
  // 完整的应用实现
}

// ==================== 主页面 ====================
class WeatherHomePage extends StatefulWidget {
  // 完整的页面实现
}

// ==================== UI组件 ====================
class WeatherCard extends StatelessWidget {
  // 完整的卡片组件实现
}

class ForecastCard extends StatelessWidget {
  // 完整的预报卡片实现
}
```

---

### 📋 功能完整性检查表（必须在最后输出）

完成所有开发后，**必须**输出以下检查表：

```
╔══════════════════════════════════════════════════════════════╗
║           功能完整性检查表 - Flutter天气APP                    ║
╠══════════════════════════════════════════════════════════════╣
║ 模块              │ 功能                    │ 状态          ║
╠══════════════════════════════════════════════════════════════╣
║ 数据模型          │ WeatherModel定义         │ ✅/❌        ║
║                   │ fromJson解析             │ ✅/❌        ║
║                   │ 所有字段完整             │ ✅/❌        ║
╠══════════════════════════════════════════════════════════════╣
║ 网络服务          │ WeatherService类         │ ✅/❌        ║
║                   │ HTTP请求实现             │ ✅/❌        ║
║                   │ 超时处理(10s)            │ ✅/❌        ║
║                   │ 错误处理                 │ ✅/❌        ║
╠══════════════════════════════════════════════════════════════╣
║ 状态管理          │ WeatherProvider          │ ✅/❌        ║
║                   │ 加载状态管理             │ ✅/❌        ║
║                   │ 错误状态管理             │ ✅/❌        ║
║                   │ 单位切换功能             │ ✅/❌        ║
╠══════════════════════════════════════════════════════════════╣
║ UI界面            │ 渐变背景                 │ ✅/❌        ║
║                   │ 城市名称显示             │ ✅/❌        ║
║                   │ 当前温度(大号)           │ ✅/❌        ║
║                   │ 天气图标                 │ ✅/❌        ║
║                   │ 详情卡片(湿度/风速)      │ ✅/❌        ║
║                   │ 3天预报卡片              │ ✅/❌        ║
╠══════════════════════════════════════════════════════════════╣
║ 交互功能          │ 下拉刷新                 │ ✅/❌        ║
║                   │ 温度单位切换             │ ✅/❌        ║
║                   │ 加载指示器               │ ✅/❌        ║
║                   │ 错误提示+重试            │ ✅/❌        ║
╠══════════════════════════════════════════════════════════════╣
║ 代码质量          │ 无TODO占位符             │ ✅/❌        ║
║                   │ 无省略代码               │ ✅/❌        ║
║                   │ 所有函数完整实现         │ ✅/❌        ║
║                   │ 代码可直接运行           │ ✅/❌        ║
╚══════════════════════════════════════════════════════════════╝

总计: XX/24 项完成
完成率: XX%
```

---

### 应用要点

- **C-角色**：定义为8年经验的Flutter高级开发工程师，强调"绝不使用占位符"
- **R-任务**：一次性输出完整APP，明确"可直接运行"要求
- **I-输入**：提供技术栈、API接口、设计要求和功能模块清单
- **S-步骤**：定义了8个清晰步骤，每个步骤有具体的实现要点
- **P-参数**：明确禁止行为（TODO、省略、空函数），约束输出格式
- **E-示例**：提供API数据格式、代码结构和完整性检查表

这个完整的**移动端CRISPE Prompt**，六要素完整且添加了强制约束，AI能生成可直接运行的Flutter应用。

---

## 总结

通过以上三个实战案例，我们可以看到CRISPE框架的强大之处：

| 场景 | 核心价值 | 输出质量 |
|------|----------|----------|
| 代码审查 | 系统化检查，不遗漏关键点 | 结构化问题清单 + 完整修复代码 |
| Bug修复 | 根因分析，量化性能提升 | 完整诊断报告 + 可运行优化方案 |
| APP开发 | 端到端实现，完整可运行 | 生产级代码 + 功能检查表 |

### CRISPE使用建议

1. **角色要专业**：定义具体的专业背景和技能领域，强调"输出完整代码"
2. **任务要明确**：清晰描述期望的最终成果，明确"一次性输出"
3. **输入要充分**：提供足够的上下文和约束条件，列出功能清单
4. **步骤要具体**：拆解任务为可执行的检查点，每步有明确产出
5. **参数要严格**：明确禁止行为（TODO、省略），设定质量标准
6. **示例要完整**：展示期望的输出格式和完整性检查表

### 强制约束建议

在P（参数）部分添加以下约束，确保AI输出完整代码：

```
禁止行为（违反即失败）:
- 禁止输出 TODO、FIXME 等占位符
- 禁止输出 "此处省略" 等省略说明
- 禁止输出不完整的函数或类
- 必须输出完整性检查表
```

掌握CRISPE框架，让你的AI对话从"试探性提问"升级为"精准任务下达"，显著提升AI输出质量和工作效率。

---

## 📎 附件下载

**CRISPE框架完整模板** - 包含详细的角色定义、任务描述、输入示例、执行步骤、参数约束和参考模板。

[🔗 下载 CRISPE Prompt框架模板](/downloads/crispe-prompt-framework-template.md)

该模板文件包含了本文中所有示例的完整版本，以及更多实用的CRISPE提示词模板，可以直接复制使用并根据具体需求进行修改。
